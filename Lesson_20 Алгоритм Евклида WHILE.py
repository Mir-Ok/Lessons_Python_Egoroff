''' Алгоритм Евклида помогает найти наибольший общий делитель двух чисел (НОД).

Например, есть число 18, которое делится без отстатка на 1,2,3,6,9,18
И есть число 30, которое делится без остатка на 1,2,3,5,6,10,15,30.
Общие делители числа 18 и 30 это 1,2,3,6. Наибольший из них 6

Алгоритм. Даны числа a и b. Пока a не равно b, находим большее из них
и уменьшаем на значение меньшего, выводим a или b.
Например, числа 21 и 35.
Шаг 1. Сравниваем, из 35 вычитаем 21, получаем 14.
Теперь у нас снова есть пара чисел, 21 (вычитаемое) и 14 (разность).
Шаг 2. Сравниваем, из 21 вычитаем 14, получаем 7.
У нас снова есть пара числе, 14 (вычитаемое) и 7 (разность).
Шаг 3. Сравниваем, из 14 вычитаем 7, получаем 7.
У нас снова есть пара чисел, 7 и 7, они равны.
Шаг 4. После достижения равенства цикл закончен, выводим одно из чисел.

Если у двух чисел НОД = 1, такие числа называют взаимнопростыми.
'''

a = 305
b = 185
while a != b:
    if a > b:
        a = a - b
    else:
        b = b - a
print(a)

# Проблема алгоритма выше в том, что при больших числах работает слишком долго.
# Нужен более оптимальный алгоритм. Например, основанный на остатках от деления.

'''
Возьмем, для примера, 1000 и 2. Видно, что первое делится на второе без остатка, и тогда второе число и есть НОД.
А если взять 1000 и 3, тогда не сработает подход выше. Потому что 1000 % 3 = 1. 
И только на этом этапе мы можем большее разделить на меньшее без остатка, и оно будет НОД.
Здесь рождается второй алгоритм.
Создадим a и b, причем условимся, что a > b. Пока a > 0, мы присваиваем a значение b, 
а в b помещаем результат от  a % b.
Пример: a = 42, b = 28.
Шаг 1. Проверяем b > 0, далее b = 42 % 28 = 14, a = 28
Шаг 2. Проверяем b > 0, далее b = 28 % 14 = 0, a = 14
Шаг 2. Проверяем b > 0, неверно, выводим значение a, которое является НОД
'''

a = 100000
b = 25
while b > 0:  # --- проверяем условие
    c = a % b  # -- высчитываем остаток от деления
    a = b  # ------ переприсваиваем значение
    b = c  # ------ кладем в переменную остаток от деления
print(a) # --> 25

# в Питоне есть операция множественного присвоения, поэтому код можно оптимизировать

a = 125
b = 25
print(a % b)
while b > 0:  # --------- проверяем условие
    a, b = b, a % b  # -- высчитываем остаток от деления
print(a) # --> 25

# Свойство! a * b = НОД * НОК, следовательно НОК = (a * b) / НОД
