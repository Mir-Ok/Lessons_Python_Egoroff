def main_func():  # --- создаем главную функцию
    def inner_func():  # --- создаем вложенную функцию
        print('hello, friens')
    inner_func()  # --- вызываем вложенную функцию внутри главной

main_func()
a = main_func()
print(a)  # --> None потому что в функции нет return, она ничего не возвращает

''' изменим ситуацию, создадим возврат, в результате помещения главной
    функции в переменную, при вызове этой переменной мы будем получать ответ (см. ниже)
    он говорит нам, что пременная ссылается на вложенную функцию, находящуюся в главной
    
    по сути, переменная b является самой функцией, ее можно вызвать  '''

def main_func():  # --- создаем главную функцию
    def inner_func():  # --- создаем вложенную функцию
        print('hello, friens')
    return inner_func  # --- возвращаем внутреннюю функцию при вызове главной

main_func()
b = main_func()
print(b)  # --> <function main_func.<locals>.inner_func at 0x000001E83C481310>

b() # --> hello, friens пример вызова переменной, которая стала функцией

''' создадим замыкание 
    для нее не хватает только переменной (свободная переменная)
    вспомним про области видимости
    переменной нет в локальной ОВ, зато она есть в нелокальной  
    
    замыкание - когда вложенная функция пользуется переменной, не объявленной в ее теле
    при этом, ВАЖНО! после отработки функции, переменная не будет удалена, хотя после стандартного вызова локальной 
    функции все переменные уходят '''

def main_func():  # --- создаем главную функцию
    name = 'Ivan'  # --- объявляем нелокальную переменную
    def inner_func():  # --- создаем вложенную функцию
        print('hello, friens', name)
    return inner_func  # --- возвращаем внутреннюю функцию при вызове главной

''' то есть мы можем вызывать функцию, передавать ей параметр и помещать значение в переменную
    немного напоминает работу с экземплярами класса
    '''

def main_func(value):  # --- создаем главную функцию
    name = value  # --- объявляем нелокальную переменную
    def inner_func():  # --- создаем вложенную функцию
        print('hello, friens', name)
    return inner_func  # --- возвращаем внутреннюю функцию при вызове главной

d = main_func('Petr')  # --> hello, friens Petr
d()
e = main_func('Anya')  # --> hello, friens Anya
e()
f = main_func('Fetr')  # --> hello, friens Fetr
f()

# --------------------- 6:04

def adder(value_a):
    def inner(value_i):
        return value_a + value_i
    return inner  # --- для создания замыкания мы должны вернуть вложенную функцию, но без вызова

a2 = adder(2)
''' создается область видимости (scope) в которой мы в value поместили 2 
    и эта область видимости с value = 2 лежит в переменной a2
    
    каждый раз, когда вызывается а2 и ей передается параметр, а2 по умолчанию 
    содержит в себе значение с value = 2
    а параметр из скобки передается в функцию inner()
    потому что а2 принимает значение функции inner()
    '''

print(a2(5))  # --> 7

a5 = adder(5)  # --> положили в value_a 5
print(a5(10))  # --> 15 положили в value_i 10 и суммировали


# --------------------- счетчик

def counter():
    count = 0  # свободная переменная
    def inner():
        nonlocal count  # указываем что ссылаемся на переменную выше
        count += 1  # изменяем переменную в другой области видимости
        return count

    return inner  # вернем саму же функцию без () чтобы создать замыкание

q = counter()
print(q())  # --> 1
print(q())  # --> 2
print(q())  # --> 3
print(q())  # --> 4

# каждый вызов показывает, сколько раз вызывалась функция

r = counter()
print(r())  # --> 1
print(r())  # --> 2

''' каждый раз, когда мы будем вызывать функцию и помещать ее в новую переменную,
    будет создаваться своя область видимости, которая будет хранить свое
    значение переменной count
    '''

''' 
внутренняя функция не будет выполняться автоматически без явного ее вызова.
через return func(не func()) функция не вызывается, а передается из "функции-обертки" в "переменную", 
после чего переменная "становится"(имя ссылается на) этой функцией.
func() - вызов функции. () - "оператор" вызова, сообщает интерпретатору, что функция "вызывается", 
т.е. выполняются, описанные в ее теле инструкции.

a = func() - в а "помещается" то, что возвращает(return) функция, либо None, когда функция не возвращает значений.
func - "имя" функции, так же, как и "имя"(ссылка) на любой другой объект.
а = func равносильно a = b(где b = 5, например), т.е. a начинает ссылаться на то же на что и func, 
 данном случае на функцию func и так же может быть вызвана через "оператор" ().

т.е. а() равносильно func().

'''

# Примеры, часть 2

''' 1. Создаем функцию, которая с каждым вызовом принимает переменную, помещает ее в список
    и находит среднее арифметическое списка
    '''
def average_numbers():
    numbers = []  # его мы ниже не делаем nonlocal списки являются изменяемыми объектами. И то что, мы с ними делаем в функции будет видно и вне функции
    def inner(number):
        numbers.append(number)
        print(numbers)
        return sum(numbers) / len(numbers)

    return inner

d1 = average_numbers()
print(d1(5))
print(d1(6))
print(d1(7))
'''вывод 
   [5]
   5.0
   [5, 6]
   5.5
   [5, 6, 7]
   6.0        
   '''

d2 = average_numbers()
print(d2(8))
print(d2(9))
print(d2(7))
'''вывод 
   [8]
   8.0
   [8, 9]
   8.5
   [8, 9, 7]
   8.0    
   '''

# Можем несколько изменить функцию, и сразу считать суммы и количество
# Но для этого переменные надо сначала объявить,
# показать из какой области видимости их брать через nonlocal

def average_numbers():
    summa = 0
    count = 0

    def inner(number):
        nonlocal summa
        nonlocal count
        summa += number
        count += 1
        return summa / count

    return inner

d3 = average_numbers()
print(d3(10))  # --> 10
print(d3(20))  # --> 15
print(d3(30))  # --> 20


''' 2. Функция-таймер, которая будет засекать время с первого вызова функции '''

from datetime import datetime

def timer():
    start = datetime.now()  # запоминаем время первого вызова
    def inner():
        return datetime.now() - start  # получаем время текущего вызова и вычитаем из него время первого
    return inner

r = timer()  # в момент вызова в переменную вернется вложенная функция
             # и инициализируется переменная start
print(r())  # --> 0:00:00 так как запускаю все одновременно разницы нет

# немного улучшим результат, чтобы получать разницу во времени в секундах

from time import perf_counter
def timer():
    start = perf_counter()  # запоминаем время первого вызова
    def inner():
        return perf_counter() - start  # получаем время текущего вызова и вычитаем из него время первого
    return inner

r1 = timer()
print(r1())  # --> 5.999999999999062e-07

''' 3. Подача функции в качестве аргумента '''

def add(a,b):
    return a+b

def counter(func):
    count = 0
    def inner(*args, **kwargs):
        nonlocal count
        count +=1
        print(f'функция {func.__name__} вызывалась {count} раз')  # func.__name__ вернет название функции
        return func(*args, **kwargs)

    return inner

q = counter(add)
print(q(10, 20))  # функция add вызывалась 1 раз 30
print(q(15, 20))  # функция add вызывалась 2 раз 35
print(q(35, 20))  # функция add вызывалась 3 раз 55

''' Как так получилось?
    Мы вызываем counter() и передаем ей параметром другую функцию add()
    В переменную func сохранится название этой функции 
    
    В переменную q сохранится замыкание, функция inner()
    
    При вызове q() с параметрами они запомнятся в параметре *args
    
    Увеличиваем счетчик
    
    Вызываем саму функцию
    
    По чути, мы вместо add() можем подать другую функцию'''

def mult(a, b, c):
    return a*b*c

m = counter(mult)
print(m(1, 20, 6))  # функция mult вызывалась 1 раз 120