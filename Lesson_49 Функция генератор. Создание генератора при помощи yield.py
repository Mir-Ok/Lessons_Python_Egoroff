# пример обычной функции

def f():
    return [43, 44, 45]

print(f())  # --> [43, 44, 45]
print(f())  # --> [43, 44, 45] вывод сколько угодно раз

# функции - генераторы могут возвращать по одному значению и замораживать свое выполнение.
# При новом вызове продолжит выполняться с того места, где остановилась

def genf():
    for i in [43, 44, 45]:
        yield i

s = genf()
print(s)  # --> <generator object genf at 0x0000014C7409FDD0> значит надо обернуть в функцию next()
print(next(s))  # --> 43
print(next(s))  # --> 43
print(next(s))  # --> 43
# print(next(s))  # --> Traceback (most recent call last): StopIteration

# либо другой способ обращения, через for который сам вызывает next()
for i in genf():
    print()
    ''' вывод: 
    43
    44
    45
    '''

''' 
Что такое инструкция yield? Она возвращает значение и замораживает функцию со
всеми локальными переменными на том месте, где остановилась.
При новом вызове стартует ровно с места остановки 
'''

def genf1():
    s = 7
    for i in [24, 25, 26]:
        yield i
        print(s)
        s = s * 10 + 7

g = genf1()
print(next(g))  # --> 24 сначала первый элемент, как только встретилась инструкция yield остановка
print(next(g))  # --> 7 при новом вызове продолжается с момента остановки, сначала довыводит принт
                # --> 25 после снова оборачивает цикл и стопорится на инструкции yield
print(next(g))  # --> 77 при новом вызове продолжается с момента остановки, сначала довыводит принт ...
                # --> 26

''' Использование на примере расчета факториала 

При использовани обычной функции создается список, причем тем длинее и тяжелее он, 
чем большее число подано в функцию.

'''

# просто функция

def fact(n):
    pr = 1
    a = []
    for i in range(1, n+1):
        pr = pr * i
        a.append(pr)
    return a

print(fact(10))  # --> [1, 2, 6, 24, 120, 720, 5040, 40320, 362880, 3628800]

# генератор

def fact(n):
    pr = 1
    for i in range(1, n+1):
        pr = pr * i
        yield pr

s = fact(10)
print(next(s))  # --> 1
print(next(s))  # --> 2
print(next(s))  # --> 6
print(next(s))  # --> 24
print(next(s))  # --> 120
print(next(s))  # --> 720
print(next(s))  # --> 5040
print(next(s))  # --> 40320
print(next(s))  # --> 362880
print(next(s))  # --> 3628800
# print(next(s))  # --> Traceback (most recent call last): StopIteration

# либо:

for i in fact(10):
    print(i, end=' ')  # --> 1 2 6 24 120 720 5040 40320 362880 3628800

