'''
Локальная ОВ создается внутри функции, и видны только внутри нее. Если обратиться к ним вне функции, получим ошибку/
Так же нельзя внутри одной функции обращаться к локальным переменным другой функции
'''

def s():
    a, b, c = 1, 2, 3  # --- локальные
    print(a, b, c)
s()
''' вывод: 1 2 3 '''

# def q():
#    e, f = 1, 2  # --- локальные
#    print(e, f, c)
# q()
# ''' вывод: NameError: name 'c' is not defined '''

''' 
Глобальная переменная создается вне тела функций. 
Так как они определены везде, внутри функций их тоже можно использовать
'''
y = 100  # --- глобальная
def s():
    a, b, c = 1, 2, 3  # --- локальные
    print(a, b, c, y)
s()
''' вывод: 1 2 3 100 '''

''' 
Внутри функции глобальную переменную можно переназначить, но в глобальном пространстве она от этого не поменяется/
'''
y = 100  # --- глобальная
def s():
    y = 200  # создаются одноименная ЛОКАЛЬНАЯ переменная, глобальная тоже сохраняется
    a, b, c = 1, 2, 3  # --- локальные
    print(a, b, c, y)
s()
print(y)
''' 
вывод: 1 2 3 200 
100
'''

''' 
ВАЖНО! Если в теле функции глобальная переменная будет перезаписываться, то вывести значение глобальной 
до переопределения нельзя, питон увидит обращение к переменной до задания и выдаст ошибку. 
'''
y = 100  # --- глобальная
def s():
    #print(y)
    y = 200  # создаются одноименная ЛОКАЛЬНАЯ переменная, глобальная тоже сохраняется
    a, b, c = 1, 2, 3  # --- локальные
    print(a, b, c, y)
s()
''' вывод: # UnboundLocalError: local variable 'y' referenced before assignment '''


# ----------------------------------------------------------------
# пример соотнесения глобальных и локальных переменных
def s():
    # local
    a = 11
    b = 22
    c = 33
    print(a,b,c,'local')
# global
a = 100
b = 200
c = 300

s()
print(a,b,c,'global')
''' вывод:
11 22 33 local
100 200 300 global
'''

def s(): # при удалении локальных функция возьмет глобальные
    # local
    b = 22
    print(a,b,c,'local')
# global
a = 100
b = 200
c = 300

s()
print(a,b,c,'global')
''' вывод:
100 22 300 local
100 200 300 global
'''


# ----------------------------------------------------------------
# пример

def s(a, b, c):  # при передаче функции аргументов - глобальных переменных,
                 # внутри функции они автоматически становятся локальными
    a = 30       # и поэтому при переопределении внутри функции вывод функции меняется
    print(a, b, c, 'local')
# global
a = 100
b = 200
c = 300

s(a, b, c)
print(a, b, c, 'global')  # глобальные переменные от этого не меняются
''' вывод:
30 200 300 local
100 200 300 global
'''

# ----------------------------------------------------------------
# пример со списком []

def s(a, b, c):  # при передаче функции аргументов - глобальных переменных,
                 # внутри функции они автоматически становятся локальными
    a[1] = 30    # и поэтому при переопределении внутри функции вывод функции меняется
    print(a, b, c, 'local')
# global
a = [1,2,3]
b = 200
c = 300

s(a, b, c)
print(a, b, c, 'global')  # глобальные переменные МОГУТ измениться, если объект изменяемый, например, список
''' вывод:
[1, 30, 3] 200 300 local
[1, 30, 3] 200 300 global
'''

# ----------------------------------------------------------------
# инструкция global позволяет менять внутри функции, вроде бы в локальной области видимости, глобальные переменные

def v():
    global a
    a = 30

a = [1,2,3,4,5]
v()
print(a, 'global')
''' вывод: 30 global '''

def v():
    # global a # -- закомментим инструкцию global и снова глобальная переменная неприкасаема
    a = 30

a = [1,2,3,4,5]
v()
print(a, 'global')
''' вывод: [1, 2, 3, 4, 5] global '''

''' 
Все, что было описано выше про области видимости переменных актиуально и для функций 

Что такое встроенная области видимости? В нее входят все встроенные функции, ключевые слова (жирным),
объекты и переменные. Чтобы увидеть их все, нажмите ctrl + Space, выпадет меню (встроенные справа отмечены buildings).

Втроенные функции можно переопределять, внутри самописных функций и вне их
'''

# ----------------------------------------------------------------
# вложенные функции

'''
Правило поиска имен.

Самое основное - большое встроенное пространство имен Built in среды Python.
Далее, внутри него, в текущем файле Lesson_38 ... есть глобальная область видимости Global.
Внутри файла при создании функций образуется их локальная область видимости, например функции s().
Если внтури функции s() мы создадим еще одну функцию q(), получится "вложенная локальность", 
 --- тогда функция s() становится объемлющей Enclosing, а q() локальной Local.

Как работает правило? Порядок поиска Local --> Enclosing --> Global --> Built in

Причем если мы хотим отменить локальность переменной, которая находится во объемлющей функции, 
то инструкция не global, а nonlocal
'''

def s():  # при появлении функции внутри автоматически становится въемлющей
    abs = 200
    def q():  # объявлена в локальной области видимости функции s(), поэтому вызывать ее мы можем только внутри s()
        abs = 'hello'
        print(abs, 'q')  # находит переменную в Local дальше не ищет
    q()
    print(abs,'s')  # находит переменную в Enclosing дальше не ищет

abs = [1,2,3]
s()
''' вывод: hello q
           200 s
'''




