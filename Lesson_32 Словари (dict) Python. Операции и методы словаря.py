'''
Словарь - неупорядоченная коллекция объектов с доступом по ключу. Другое название - ассоциативный список (массив).
Общий вид:

d = {
     ключ:значение
     key:value
     }

Словари создаются 5 способами, см. ниже. Основные 1 и 5, остальные редко.

Ключами могут быть строки и числа, т.е. только неизменяемые  объекты. Иначе ошибка unhashable type: list
Значениями могут быть любые типы, могут быть разнотипные в рамках одного словаря.

Обращение к ключам, см. ниже

'''

a = ['moskva', 'piter', 'penza']  # по умолчанию, каждый элемент списка ассоциирован с индексом элемента.
                                  # А может, мы хотим ассоциировать с кодом города?


# ----------------------------------------------------
# создание словарей

# 1-й способ создания словаря, напрямую

b = {
    'moskva' : 495,
    'piter' : 812,
    'penza' : 8412
    }
print(b)  # --> {'moskva': 495, 'piter': 812, 'penza': 8412}

# 2-й способ создания словаря, через функцию

c = dict(moskva=495, piter=812, penza=8412)
print(c)  # --> {'moskva': 495, 'piter': 812, 'penza': 8412}

''' 
функция dict() автоматически переводит ключи в строки, кавычки не нужны. 
Но если мы попробуем взять ключами цифры, надеясь на перевод их в строку, возникнет ошибка:
d = dict(1=495, 2=812, 3=8412) 
print(d)  # --> SyntaxError: expression cannot contain assignment, perhaps you meant "=="?
'''

# 3-й способ создания словаря, через вложеный список и функцию

e = [['moskva',495], ['piter',812], ['penza',8412]]
f = dict(e)
print(f)  # --> {'moskva': 495, 'piter': 812, 'penza': 8412}

# 4-й способ создания словаря, через функцию и ее метод

q = dict.fromkeys(['a', 'b', 'c'])
print(q)  #--> {'a': None, 'b': None, 'c': None}

q = dict.fromkeys([1, 2, 3])
print(q)  #--> {1: None, 2: None, 3: None}

q = dict.fromkeys(['a', 'b', 'c'], 100)  # инициализируем словарь с разными ключами и одним значением
print(q)  #--> {'a': 100, 'b': 100, 'c': 100}

# 5-й способ создания словаря, пустого

v = {}
print(v, type(v))  #--> {} <class 'dict'>
v = dict()
print(v, type(v))  #--> {} <class 'dict'>


# ----------------------------------------------------
# обращение к значениям возможно обращаться через ключ. Внимание, не по индексу, а по ключу!

b = {
     1 : 495,
     2 : 'two',
     3 : [1,2,3]
     }

print(b[1])  # --> 495
# print(b[0])  #--> KeyError: 0 ошибка ключа, т.к. такого не существует.


# ----------------------------------------------------
# добавление значений в словарь
#     присваиваем несуществующему ключу новое значение

d = {1 : 495, 2 : 'two', 3 : [1,2,3]}
d[4] = 'four'
print(d)  # --> {1: 495, 2: 'two', 3: [1, 2, 3], 4: 'four'}


# ----------------------------------------------------
# изменение значений в словаре
#     присваиваем существующему ключу новое значение, старое перезаписывается

d = {1 : 495, 2 : 'two', 3 : [1,2,3]}
d[3] = 'four'
print(d)  # --> {1: 495, 2: 'two', 3: 'four'}


# ----------------------------------------------------
# удаление значений в словаре (только для существующих ключей, иначе ошибка)

z = {1 : 'one', 2 : 'two', 3 : 'three'}
del z[1]
print(z)  # --> {2: 'two', 3: 'three'}


# ----------------------------------------------------
# функции словаря

print(len(z))  # ----------------------------  длина словаря
if 5 in z:  # -------------------------------  проверка наличия ключа
    print(z[5])
else:
    z[5] = 'five'
print(z)  # --> {2: 'two', 3: 'three', 5: 'five'}

for key in z:  # ------------------------------  обход словаря циклом
    print(key, z[key])
''' вывод
2 two
3 three
5 five
'''


# ----------------------------------------------------
# методы словаря

# _1 полная очистка ключей и значений
z = {1 : 'one', 2 : 'two', 3 : 'three'}
z.clear()
print(z)  # --> {}

# _2 получение значения по ключу .get() при отсутствии выводит None
z = {1 : 'one', 2 : 'two', 3 : 'three'}
print(z.get(1))  # -->  one

z = {1 : 'one', 2 : 'two', 3 : 'three'}
print(z.get(4))  # -->  None

z = {1 : 'one', 2 : 'two', 3 : 'three'} # при отсутствии ключа метод вернет значение после запятой (список, число, строку)
print(z.get(4, 'No such key'))  # --> No such key

# _3 получение значения по ключу .setdefaul() - МОЖЕТ ИЗМЕНЯТЬ СЛОВАРЬ
# --- при отсутствии ключа создает его с пустым значением
# --- при наличии ключа выводит значение
# --- при отсутствии можем сразу задать значение .setdefault(6, '240')
# --- при вызове существующего способом выше, старый ключне переписывается
z = {1 : 'one', 2 : 'two', 3 : 'three'}
print(z.setdefault(6))  # --> No such key
print(z)  # --> {1: 'one', 2: 'two', 3: 'three', 6: None}

# _4 возврат значения и удаление его из словаря .pop()
z = {1 : 'one', 2 : 'two', 3 : 'three'}
print(z.pop(3))  # -->  three
# print(z.pop(4))  # -->  KeyError: 4

# _5 возврат и удаление случайной пары .popitem()
z = {1 : 'one', 2 : 'two', 3 : 'three'}
print(z.popitem())  # -->  (3, 'three')

# _6 получение всех ключей словаря .keys()
z = {1 : 'one', 2 : 'two', 3 : 'three'}
print(z.keys())  # --> dict_keys([1, 2, 3])

for key in z:
    print(key, z[key])
    ''' вывод 
    1 one
    2 two
    3 three
    '''
for key in z.keys():  # не указано прямо выше, но мы по сути проходим результат работы метода
    print(key, z[key])
    ''' вывод 
    1 one
    2 two
    3 three
    '''

# _7 получение всех значений словаря .values()
z = {1 : 'one', 2 : 'two', 3 : 'three'}
print(z.values())  # --> dict_values(['one', 'two', 'three'])

for value in z.values():  # так можно обратиться только к значениям, ключи заодно не вывести
    print(value)
    ''' вывод 
    one
    two
    three
    '''

# _8 возврат всей коллекции пар (всего словаря)
z = {1 : 'one', 2 : 'two', 3 : 'three'}
print(z.items())  # --> dict_items([(1, 'one'), (2, 'two'), (3, 'three')])

for para in z.items():  # так можно вывести кортежи из пар
    print(para)
    ''' вывод 
    (1, 'one')
    (2, 'two')
    (3, 'three')
    '''
for para in z.items():  # индексация кортежей аналогична спискам
    print('Ключ: ', para[0], 'Значение: ', para[1])
    ''' вывод 
    Ключ:  1 Значение:  one
    Ключ:  2 Значение:  two
    Ключ:  3 Значение:  three
    '''
for key, value in z.items():  # через множественное присвоение
    print('Ключ: ', key, 'Значение: ', value)
    ''' вывод 
    Ключ:  1 Значение:  one
    Ключ:  2 Значение:  two
    Ключ:  3 Значение:  three
    '''


# ----------------------------------------------------
# задание - заполнить пустой словарь значениями

person = {}  # создаем пустой словарь
s = 'Ivanov Ivan Samara SGU 5 4 5 5 4 3 5'

s = s.split()  # разбиваем на элементы
print(s)  # --> ['Ivanov', 'Ivan', 'Samara', 'SGU', '5', '4', '5', '5', '4', '3', '5']

person['lastName'] = s[0]
person['firstName'] = s[1]
person['city'] = s[2]
person['univer'] = s[3]
person['marks'] = []  # для оценок создаем список пустой и заполняем его элементами, начиная с 4 (переводя их в цифры)
for i in s[4:]:
    person['marks'].append(int(i))
print(person)