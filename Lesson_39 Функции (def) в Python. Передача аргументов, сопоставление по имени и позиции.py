# ------------------------------------------------------
# _1 Передача аргументов

def f(a, b):
    a = 100  # local
    b = 200  # local
    print(a, b, 'local')

c = 20  # global
d = 50  # global

f(c, d)
''' вывод: 100 200 local '''
print(c, d, 'global')
''' вывод: 20 50 global '''

''' В момент передачи переменных функции (строка 9) в  локальную переменную a помещается значение глобальной с, 
    в  локальную переменную b помещается значение глобальной d.
    Помним, что в переменных находятся ссылки на объекты, проверим идентификаторы. При присвоении локальным переменным 
    значений глобальныч идентификационные номера совпадают  
'''
def f(a, b):
    print(id(a), id(b), 'local')
    a = 100  # local
    b = 200  # local

c = 20  # global
d = 50  # global
print(id(c), id(d), 'global')
f(c, d)
''' вывод: 
    140706302536064 140706302537024 global
    140706302536064 140706302537024 local
'''

''' При локальном изменении переменных их идентификаторы менятся, ссылаются на другие области памяти.
    Важно помнить, что при обращении к изменяемым объектам, мы можем локально поменять их глобальные значения.
    Например, внутри функции добавить элемент списка, и в выводе вне функции он тоже поменяется. Это происходит потому,
    что глобальная и локальная переменная ссылаются на один и тот же список
'''
def f(a, b):
    print(id(a), id(b), 'local')
    a = 100  # local
    b.append(188)  # local, но изменит глобальную переменную
    print(id(a), id(b), 'local after')

c = 20  # global
d = [1,2,3,4,5]  # global
print(id(c), id(d), 'global')
f(c, d)
print(c, d, 'global')
''' вывод: 
    140706302536064 140706302537024 global
    140706302536064 140706302537024 local
    140706302538624 140706302541824 local after
    20 [1, 2, 3, 4, 5, 188] global
'''
# Чтобы избежать изменения исходника, в функцию стоит передавать полную копию, например, срезом f(c, d[:]),
# и тогда все действия внутри функции происходят над копией


# ------------------------------------------------------
# _2 Сопоставление аргументов

def f(a,b,c):
    print(a,b,c)

f(1,2,3)  # позиционный способ подачи, подаем ровно столько, сколько при задании функции
''' вывод: 1 2 3'''

f(b=1, c=2, a=3)  # именованный способ подачи, подаем только по тем именам, что при задании функции указали
''' вывод: 3 1 2 порядок сохраняется правильный, a b c '''

f(1, c=2, b=3)  # комбинированный, причем сначала позиционные, потом именованые
''' вывод: 1 3 2'''

# _3 Предопределенные аргументы
# ВАЖНО! при объявдении функции сначала идут обязательные аргументы, потом именованные.
# Нельзя писать def f(a = 11, b, c = 'Неизвестно')

def f(a,b,c = 'Неизвестно'): # с одним предопределенным, его можно переназначить при вызове
    print(a,b,c)
f(2,3)  # вызов двух из трех сохраняет значение предопределенного
''' вывод: 2 3 Неизвестно '''
f(2, 3, 4)  # вызов трех перезаписывает предопределенное значение
''' вывод: 2 3 4 '''

def f(a = 1,b = 'hi', c = 'Неизвестно'):
    print(a, b, c)

# вызов функции и подача позиционных аргументов
f()  # вывод всех заданных
''' вывод: 1 hi Неизвестно '''
f(2)  # вывод всех заданных, кроме одной
''' вывод: 2 hi Неизвестно '''
f(2, 3)  # вывод всех заданных, кроме двух
''' вывод: 2 3 Неизвестно '''
f(2, 3, 4)  # вывод всех переопределенных
''' вывод: 2 3 4 '''

# вызов и подача именованных тоже возможна

def f(a, b, c = 111, d = 222):
    print(a, b, c, d)

f(1, 2, 3)  # --------- подаем позиционно два обязательных, переписываем один предопределенный, четвертый предопределенный не трогаем
f(10, 20)   # --------- подаем позиционно два обязательных, предопределеные сохраняются
f(b=10, a=20)  # ------ подаем по имени два обязательных
f(10, d=10, b=20)  # -- подаем первый обязательный позиционно, переписываем четвертый предопределенный, подаем второй обязательный по имени


''' ВАЖНО! Аккуратно используйте изменяемые объекты в значениях по умолчанию '''

# определим функцию, которая принимает на вход значение и список, и в ходе работы
# помещает значение в список

def append_to_list(value, my_list):
    my_list.append(value)
    print(my_list)

append_to_list(10, [1,2,3])  # --> [1,2,3,10]

# Что будет, если мы попробуем предопределить  my_list = [] сразу при создании функции?
# Вспомним, что переменные хранят не объекты, а ссылки на них. И если есть а = 1, то в а
# лежит идентификатор ссылки на 1, и если мы пропишем b = a, то аккуратнее с изменениями b

''' поэтому при def append_to_list(value, my_list = []) каждый вызов функции будет наполнять один и тот же список, 
    а не создавать новый '''

def append_to_list(value, my_list = None):
    if my_list is None:
        my_list = []
    my_list.append(value)
    print(my_list)

# теперь словарь будет переочищаться каждый раз перед вызовом функции
