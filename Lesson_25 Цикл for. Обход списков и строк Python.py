'''
При переборе цикл for будет поочередно присваивать переменной i одно значение из списка

Два варианта:
1. обход по значеним (ограниченный, только работа с самим значением)
2. обход по индексам (универсальный, найти номер элемента, соседние и пр.)
'''


a = [43, 65, 3, 54, 6]
count = 0
for i in a:
    print(i, end=' ')
    count += 1
    print(count, 'обход')
    input() # ---> # пустой не требует ввода, просто ждет нажатия enter

''' вывод 
43 1 обход
65 2 обход
3 3 обход
54 4 обход
6 5 обход

'''

# мы можем изменять переменную цикла на основе входящего листа, сам лист будет неизменным,
# т.к. копия не влияет на оригинал

a = [43, 65, 3, 54, 6]
count = 0
for i in a:
    i += 5
    print(i)
print(a)
''' вывод 
48
70
8
59
11
[43, 65, 3, 54, 6]
'''

# вывести все элементы списка и их индекс
a = [43, 65, 3, 54, 6]
for i in a:
    print(i, a.index(i))
''' вывод
43 0
65 1
3 2
54 3
6 4
'''

# ВАЖНО! Если в списке есть повторы, метод индекс сработает не так, как нам надо, т.к. найденному ранее числу
# уже поставлен в соответствие индекс, вторая встреча ничего не изменит
a = [43, 65, 3, 54, 43, 6]
for i in a:
    print(i, a.index(i))
''' вывод
43 0
65 1
3 2
54 3
43 0 <--- вот здесь провал 
6 5
'''

# Вывод: при обходе элементов по значениям мы не можем изменять список,
# и не можем определять индексы элементов корректно. Нужно новое решение, обход по индексам.

''' 
a = [43, 65, 3, 54, 43, 6]

for i in range(8):  # если указанное число будет меньше (не пройдет весь лист),
                    # больше длины списка - list index out of range
    print(i, a[i])  # можем обратиться как к самому элементу (счерез индекс), так и к его индексу

0 43
1 65
2 3
3 54
4 43
5 6

Traceback (most recent call last):
  File "D:/1_Python/Уроки Egoroff/Lesson_25 Цикл for. Обход списков и строк Python.py", line 76, in <module>
    print(i, a[i])
IndexError: list index out of range

'''

a = [43, 65, 3, 54, 43, 6]

for i in range(len(a)):  # кладем в range длину листа, кот. высчитввается автоматически
    print(i, a[i])
''' вывод 
0 43
1 65
2 3
3 54
4 43
5 6
'''

# ------- Задача: убрать все дубли из списка

a = [1, 2, 3, 4, 32, 4, 5, 3, 5]
b = []

for i in a:          # перебираем последовательно элементы списка а
    if not i in b:   # если их нет еще в списке b
        b.append(i)  # добавляем в него
print(b)  # ---> [1, 2, 3, 4, 32, 5]

# ------- Задача: разнести по спискам номера четных и нечетных элементов
a = [1, 2, 3, 4, 32, 4, 5, 3, 5]

chet = []
nechet = []

for i in range(len(a)):  # перебираем не сами элементы, а их индексы по всей длине списка
    if a[i] % 2 == 0: # проверяем на четность, и если да, то
        chet.append(i + 1)  # добавляем в список номер четного элемента (а не его самого), +1 для обычного вида
    else: # проверяем на четность, и если да, то
        nechet.append(i + 1)  # добавляем в список номер четного элемента (а не его самого)
print('Номера четных: ', chet)  # ---> Номера четных:  [2, 4, 5, 6]
print('Номера нечетных: ', nechet) # ---> Номера нечетных: [1, 3, 7, 8, 9]

# ------- Задача: пройти по всем элементам строки

d = 'hello world'
for i in d:
    print(i, end = ' ')  # в выводе все буквы последовательно h e l l o   w o r l d

print()

d = 'Hello World'
for i in d:
      if 'a' < i < 'z':
        print(i, 'small ')
      elif 'A' < i < 'Z':
          print(i, 'big ')
      else:
          print(i)
''' вывод
H big 
e small 
l small 
l small 
o small 
 
W big 
o small 
r small 
l small 
d small 
'''

# ------- Задача: вывести соседние пары, в которых обе буквы гласные

vowels = 'aeiou'
s = 'aertiooikjoaikl'

# если элемент имеет индекс 1, то его сосед справа - 2.
# Если индекс элемента n, то соседа справа n+1.
# Значит, мы обходим строку по индексам, т.к. нам нужны номера символов

n = len(s)
for i in range(n - 1): # т.к. у последнего элемента нет пары, иначе out of range
    if s[i] in vowels and s[i+1] in vowels:
        print(s[i], s[i+1])
''' вывод 
a e
i o
o o
o i
o a
a i
'''
