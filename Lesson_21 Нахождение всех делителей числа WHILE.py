# Делитель - это такое число, на которое можно разделить без остатка.
# Минимальное = 1, максималльное - само это число.

n = int(input())

i = 1
while i <= n:
    if n % i == 0:
        print(i, end=' ')

    i += 1

# Алгоритм простой и понятный, но неэффективный,
# т.к. при вводе 1 000 000 цикл будет крутиться столько же раз, долго

''' 
Для любого числа верно, что его без остатка делит само число, половина числа и ряд чисел меньше половины. 
То есть мы можем отбросить смело те числа, что больше половины.  i <= n // 2 
и добавить вывод самого числа отдельным принтом
'''

n = int(input())

i = 1
while i <= n // 2:
    if n % i == 0:
        print(i, end = ' ')

    i += 1
print(n)

# Алгоритм стал эффективнее в два раза, но все еще остается линейным (увеличение числа вызывает увеличение итераций).

'''
Заметим закономерность. 
Например, для числа 36 все его делители попарны, т.к 1*36 = 2*18 = 3*12 = 4*9 = 6*6.
Следовательно, любое число n мы можем представить как произведение пары его делителей a * b, один из членов пары - НОД.
Причем a <= b, максимум a = b. В этом случае число является квадратом его делителей a * a = a ** 2 = n, 
и, следовательно a = n ** (1/2). Поэтому мы можем поискать самый младший делитель, и он будет лежать до n ** (1/2).
А зная один из делителей, мы можем легко найти второй, разделив произведение на первый делитель
'''
n = int(input())  # ------------ вводим число
i = 1  # ----------------------- устанавливаем счетчик
while i <= n ** 0.5:  # -------- находим соотношение младшего (i) и старшего делителей (n)
    if n % i == 0: # -----------
        print(i, n // i)
    i += 1

# Улучшим код.
# Избавимся от корня, соберем все делители в список и упорядочим его

n = int(input())  # ------------ вводим число
i = 1  # ----------------------- устанавливаем счетчик
a = []  # ---------------------- пустой список
while i * i <= n:  # ----------- находим соотношение младшего (i) и старшего делителей (n)
    if n % i == 0:  # ---------- проверяем равенство делителей
        if i == n//i:  # ------- если делители равны
            a.append(i)  # ----- добавляем в список только один из них
        else:  # --------------- если нет
            a.append(i)  # ----- добавляем в список первый
            a.append(n//i)  # -- добавляем в список второй
    i += 1  # ------------------ увеличиваем счетчик
a.sort()  # -------------------- сортируем список по возрастанию
print(a)


#  Оптимизируем код снова. Выносим повторяющийся элемент за условный оператор

n = int(input())  # ------------ вводим число
i = 1  # ----------------------- устанавливаем счетчик
a = []  # ---------------------- пустой список
while i * i <= n:  # ----------- находим соотношение младшего (i) и старшего делителей (n)
    if n % i == 0:  # ---------- проверяем равенство делителей
        a.append(i) # ---------- добавляем в список первый
        if i != n//i:  # ------- если делители НЕ равны
            a.append(n//i)  # -- добавляем в список второй
    i += 1  # ------------------ увеличиваем счетчик
a.sort()  # -------------------- сортируем список по возрастанию
print(a)

'''
Последний вариант имеет не линейную, а квадратичную зависимость. Эффективность в разы выше
'''