a = [[0, 2, 4, 6], [1, 5, 9, 13], [3, 10, 17, 19]]  # --- нажимаем ctrl + alt + L для форматирования по стандарту PeP8

print(len(a))  # -- если вывести длину списка, она равна 3, т.к. каждый лист - это элемент, хотя и составной
print(a[2])  # ---- [3, 10, 17, 19]
print(a[2][2])  # - 17

a = [[0, 2, 4, 6], [1, 5, 9, 13], [3, 10, [4, 5 , 7 ,11], 17, 19]]  # --- вложенность может быть любого уровня

print(len(a))  # ----- если вывести длину списка, она равна 3, т.к. каждый лист - это элемент, хотя и составной
print(a[2])  # ------- [3, 10, [4, 5, 7, 11], 17, 19]
print(a[2][2])  # ---- [4, 5, 7, 11]
print(a[2][2][2])  # - 7

b = ['hello', 'hi', 'world']  # символы внутри строкового элемента тоже является вложенным списком, по сути
print(b[1])  # ---- 'hi'
print(b[1][1])  # - i

''' вложенные списки - это, по сути, таблицы.
Варианты обхода:
1. по значениям, тогда в i помещаем сам элемент. Дает только вывод, никак повлиять на момер или значение в списке нельзя
2. по индексам
'''

a = [[0, 2, 4, 6], [1, 5, 9, 13], [3, 10, 17, 19]]

for i in a:  # -- 1. по значениям
    print(i) # переменная хранит в себе элемент списка
''' вывод 
[0, 2, 4, 6]
[1, 5, 9, 13]
[3, 10, 17, 19]
'''

for i in a:  # ----- переменная хранит в себе составной элемент списка a[i]
    for j in i:  # - переменная перебирает элементы составного элемента a[i]
        print(j, end = ' ')
    print()
''' вывод 
0 2 4 6 
1 5 9 13 
3 10 17 19 

При воздействии на значение, например, j + 10 изменится только вывод, исходный список сохранится
'''

# ------------------------------------

''' Представим наш список списков в виде таблицы, с нумерацией вдоль строк и столбцов, соотв. 
к каждому элементу можно обратиться: 
a[0][0] = 0
a[1][1] = 5

a = [
    [0, 2, 4, 6], 
    [1, 5, 9, 13], 
    [3, 10, 17, 19]
    ]

Для перебора циклом сначала фиксируем номер строки, внутри - номер столбца
'''

for i in range(3):
    for j in range(4):
        print(a[i][j], end = ' ')
    print()

''' вывод 
0 2 4 6 
1 5 9 13 
3 10 17 19 

При вызове но индексу разница в том, что при изменении мы можем воздействовать на исходный список. 
Если перед выводом добавить a[i][j] += 10, то исходный лист а станет таким:
[
[10, 12, 14, 16], 
[11, 15, 19, 23], 
[13, 20, 27, 29]
]
'''

# при переборе по индексам мы можем двигаться в любом направлении

# перебор по столбцам, для этого меняем местами обращение к строкам и столбцам (делаем наоборот, сначала j, потом i)

z = [
     [0, 2, 4, 6],
     [1, 5, 9, 13],
     [3, 10, 17, 19]
     ]

for j in range(4):  # ----------- сначала фиксируем номер столбца
  for i in range(3):  # --------- перебираем строки столбца j, пока он зафиксирован
    print(z[i][j], end=' ')  # -- обращение к элементу не изменяется
  print()
'''  вывод 
0 1 3 
2 5 10 
4 9 17 
6 13 19 
'''

# перебор от нижнего правого угла по строкам

z = [
     [0, 2, 4, 6],
     [1, 5, 9, 13],
     [3, 10, 17, 19]
     ]

for i in range(2, -1, -1):  # начиная со 2 по -1 невключительно, в обратном направлении
  for j in range(3,-1,-1):
    print(z[i][j], end = ' ')
  print()
''' вывод 
19 17 10 3 
13 9 5 1 
6 4 2 0 
'''

# перебор от нижнего правого угла по столбцам

z = [
     [0, 2, 4, 6],
     [1, 5, 9, 13],
     [3, 10, 17, 19]
     ]

for j in range(3,-1,-1): # начиная с 3 по нулевой, в обратном направлении
  for i in range(2, -1, -1):
    print(z[i][j], end = ' ')
  print()
''' вывод 
19 13 6 
17 9 4 
10 5 2 
3 1 0 
'''

# сумма построчно

z = [
     [0, 2, 4, 6],
     [1, 5, 9, 13],
     [3, 10, 17, 19]
     ]

for i in range(3):
  sum = 0  # сумма создается пустой после закрепления строки, а это значит,
           # что она будет обнуляться перед каждой итерацией вложенного цикла
  for j in range(4):
    sum += z[i][j]
  print(sum)
''' вывод 
12
28
49
'''

# сумма по столбцам

z = [
     [0, 2, 4, 6],
     [1, 5, 9, 13],
     [3, 10, 17, 19]
     ]

for j in range(4):
  sum = 0
  for i in range(3):
    sum += z[i][j]
  print(sum)
''' вывод 
4
17
30
38
'''

# ------------------------------------

''' Заполнение элементов списка '''

a = []
n = int(input())  # ---- 3 строк
m = int(input())  # ---- 3 столбцов
for i in range(n):  # -- в каждую строку
  a.append([0] * m)  # - кладем m одинаковых элементов
print(a)  # --> [[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0]]

for i in a:
  print(i)
''' вывод 
[0, 0, 0, 0]
[0, 0, 0, 0]
[0, 0, 0, 0]
'''

# ------------------------------------

''' Заполнение  квадратной матрицы '''

# Главная диагональ - от верхнего левого угла до нижнего правого (только у квадратной)
# Выше нее - i < j (номер строки меньше номера столбца), ниже нее i > j (наоборот)

m = []
n = int(input())

for i in range(n):  # -- сначала заполним матрицу нулями
  m.append([0] * n)
for i in m:  # --------- выведем для проверки
  print(i)
''' вывод 
[0, 0, 0, 0, 0, 0, 0, 0]
[0, 0, 0, 0, 0, 0, 0, 0]
[0, 0, 0, 0, 0, 0, 0, 0]
[0, 0, 0, 0, 0, 0, 0, 0]
[0, 0, 0, 0, 0, 0, 0, 0]
[0, 0, 0, 0, 0, 0, 0, 0]
[0, 0, 0, 0, 0, 0, 0, 0]
[0, 0, 0, 0, 0, 0, 0, 0]
'''

for i in range(n):
  for j in range(n):
    if i == j:      # главная диагональ
      m[i][j] = 10
    elif i > j:     # ниже
      m[i][j] = 1
    else:           # выше
      m[i][j] = 8

for i in m: # выведем для проверки
  print(i)
''' вывод 
[10, 8, 8, 8, 8, 8, 8, 8]
[1, 10, 8, 8, 8, 8, 8, 8]
[1, 1, 10, 8, 8, 8, 8, 8]
[1, 1, 1, 10, 8, 8, 8, 8]
[1, 1, 1, 1, 10, 8, 8, 8]
[1, 1, 1, 1, 1, 10, 8, 8]
[1, 1, 1, 1, 1, 1, 10, 8]
[1, 1, 1, 1, 1, 1, 1, 10]
'''

