''' модуль - это любая программа, написанная в отдельном файле и сохраненная в формате .py
    важные атрибуты - имя, расположение и пространство имен (в него попадают все переменные из
    глобальной области видимости, см файл import_st_library.py)

    Плюсы:
    - позволяет повторно использовать код без нагромождений
    - позволяет использовать чужой, готовый код

    Подробнее обо всех стандартных модулях docs.python.org/library/
    '''

import calendar  # при попытке его импорта программа подсказывает,
                 # потому что он входит в стандартную библиотеку
                 # https://docs.python.org/3/library/calendar.html

c = calendar.TextCalendar()
print(c.formatyear(2020))

''' в выводе красивая раскладка дат
    всего две строчки кода, при условии импорта модуля и знания, 
    к каким функциям можно обратиться'''

import pprint  # модуль красивой печати pretty print

def say_hello(name):
    print(f'Hello, {name}')

def summa(*args):
    return sum(args)

def factorial(n):
    pr = 1
    for i in range(1,n+1):
        pr *= i
    return pr

my_str = 'you are breathtaking!'
my_mum1 = 2
my_num2 = 3

pprint.pprint(locals())  # красиво выведет словарь, содержащий все адреса и имена

''' вывод 
    {'__annotations__': {},
     '__builtins__': <module 'builtins' (built-in)>,
     '__cached__': None,
     '__doc__': None,
     '__file__': 'D:/1_Python/Уроки Egoroff/import_st_library.py',
     '__loader__': <_frozen_importlib_external.SourceFileLoader object at 0x000001C557A10880>,
     '__name__': '__main__',
     '__package__': None,
     '__spec__': None,
     'factorial': <function factorial at 0x000001C557EB6430>,
     'my_mum1': 2,
     'my_num2': 3,
     'my_str': 'you are breathtaking!',
     'pprint': <module 'pprint' from 'C:\\Users\\User\\miniconda3\\lib\\pprint.py'>,
     'say_hello': <function say_hello at 0x000001C557C01310>,
     'summa': <function summa at 0x000001C557EB63A0>}
 '''

# Обратите внимание, что инструкция import добавляет имя в пространство имен

import math

pprint.pprint(dir(math))  # вызовем пространство имен
''' вывод 
    ['__doc__',
     '__loader__',
     '__name__',
     '__package__',
     '__spec__',
     'acos',
     'acosh',
     ...
     'tau',
     'trunc']
'''

# в списке выше неясно, что именно такое перечисленно - переменная, функция и пр.
# поэтому можно зажать CTRL, навести на название модуля и перейти
# в него (откроется описание отдельным файлом)

print(math.pi)  # --> 3.141592653589793 аналогично можем обращаться к остальным переменным модуля
print(math.factorial(10))  # --> 3628800 обращение к встроенным в модуль функциям

# ---------------------- вариант импорта с псевдонимом

import math as m
print(m.pi)  # --> 3.141592653589793 обращение через псевдоним

# ---------------------- вариант импорта части модуля
# ВАЖНО! при импорте не допустить повтора имен, иначе последняя упомянутая затирает предыдущую

from math import e, pi, factorial  # имена подключаться в область видимости напрямую, без указания имени модуля
print(e, pi)  # 2.718281828459045 3.141592653589793 обращаться тоже можно напрямую, без указания модуля
print(factorial(3))

from math import factorial as fuct
print(fuct(3))

# ---------------------- вариант импорта всех имен модуля
from math import *  # плохой вариант, никогда не знаешь что подгрузил и что перезатрется

''' Стандарт: при импорте модуля каждый отдельно, при импорте имен из модуля через запятую одной строкой'''

# импорт собственного модуля

import import_st_library
print(import_st_library.factorial(3))  # 6 можем обратиться к любой переменной или функции модуля через .

from import_st_library import my_str
print(my_str)  # --> you are breathtaking!


''' Как происходит импортирование "под капотом?"

    1. Питон ищет указанный файл, причем мы не прописываем путь к нему. 
    При этом Питон пользуется модулем sys'''

import sys
print(sys.path)
''' вывод  
    ['D:\\1_Python\\Уроки Egoroff', 'D:\\1_Python\\Уроки Egoroff', 'C:\\Users\\User\\miniconda3\\python38.zip', 'C:\\Users\\User\\miniconda3\\DLLs', 'C:\\Users\\User\\miniconda3\\lib', 'C:\\Users\\User\\miniconda3', 'C:\\Users\\User\\miniconda3\\lib\\site-packages', 'C:\\Users\\User\\miniconda3\\lib\\site-packages\\win32', 'C:\\Users\\User\\miniconda3\\lib\\site-packages\\win32\\lib', 'C:\\Users\\User\\miniconda3\\lib\\site-packages\\Pythonwin']

    выше отображены все стандартные папки, в которых Питон ищет модуль
    видим, что можно спокойно импортировать то, что лежит в одной папке с основным файлом
    
    если модуль лежит в той же режиссерии, но в дополнительной папке dir , то при вызове модуля
    from dir.import_st_library import my_str
    если файл в папке dir, а модуль выше на уровень - найдет без проблем
    
    если модули разбросаны по компу, то добавим путь в, так как sys.path - это обычный список
    sys.path.append(' .../ путь ') '''

''' 2. Отыскав путь, Питон превращает его в byte-code, язык понятный машине. Нам не особо важно '''

'''' 3. После импорта Питон весь модуль запускает на исполнение, выполнит все сверху вниз. 
    В этом можно убедиться, если в модуле расставить принты, импортировать модуль в пусой файл и запустить его, 
    в консоли все обобразится
    '''

''' 4. Модуль импортируется только один раз. Если импортировать модуль, вывести переменную из него, 
    перезаписать значение этой переменной, а после импортировать модуль и снова вызвать переменную, она
    не будет равна исходной, потому что второй раз РЕимпорта не будет 
    
    Кроме случаев, когда вы вручную импортируете модуль importlib и при помощи его функции reload() 
    РЕимпортировать моудль (его название в скобках)
    importlib.reload(import_st_lib) '''

# Если файлы импортирую друг друга - получается интересный эффект

# Например, module1 импортирует в начале module 2, а после принтит module1
# module2 импортирует в начале module 1, а после принтит module2
# При запуске module1 он встретит строку импорта module2, начнет отработку команд оттуда.
# Первая команда - импорт module1, в котором дано задание вывести module1.
# Далее выполняется вторая команда module2, то есть вывод module2
# И, когда инструкции module2 заканчиваются, программа продолжает отрабатывать module1 и
# выводит на печать module1

''' У каждого файла есть имя '''
print(__name__)  # --> __main__ если файл запускается

print(__name__)  # --> dir.my_module если в файле есть импортированные файлы, их имена равны их названиям
                 # --> __main__

# Важно! Мы можем закрыть какие-то команды файла при запуске его в другом файле через импорт,
# она сработает только в родном файле
if __name__ == '__main__':
    print(123)

