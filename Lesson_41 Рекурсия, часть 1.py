''' Рекурсия - функция, которая вызывает сама себя.

def rec(x):
    print(x)
    rec(x)

Есть ограничение глубины рекурсии, примерно 1000, после чего программа выдает ошибку, поэтому должно
быть условие выхода из нее в теле самой программы
'''

def rec(x):
    if x < 4:
        print(x)
        rec(x+1)
        print(x)
rec(1)
''' вывод: 
    1 
    2
    3
    3
    2
    1

Как идет обработка? Вызываем функцию глобально, подаем 1 в функцию, проверяем условие 1 < 4, верно, 
поэтому выводим х. В теле глобальной функции прописан локальный вызов этой же функции, поэтому далее после вывода 
вызываем функцию с аргументом x+1.
Словно мы входим в функцию, выполняем ее часть, встречаем вызов этой же функции, откладываем часть функции и начинаем 
снова выполнять первую с другим аргументом, выполняем ее часть, снова встречаем вызов и т.д., пока условие 
не перестанет выполняться. В этот момент функция дойдет до конца свой последний вызов, а далее начнут закрываться те 
части функций, что до этого были отложены. "Отскочив в сторону"

rec1 вызывает rec2, не завершившись до конца. 
    rec2 частично орабатывает, вызывает rec3. 
        rec3 частично орабатывает, вызывает rec4 (кот. не проходит по условиям), возврат к завершению rec3
    по окончании возврат на уровень выше, завершение rec2
по окончании возврат на уровень выше, завершение rec1

Стек вызовов - хранит в себе последовательность производимых операций (см. выше).
'''

# Классическая задача на рекурсию: факториал

def fact(x):
    if x == 1:
        return 1
    return fact(x-1) * x
''' 
Рекуррентная формула выглядит так:
     | -
n! = | 1, если n = 1
     | (n-1) * n , если x > 1

Факториал 5 включает в себя факториал 4, умноженный на 5. Факториал 4 включает в себя факториал 3, умноженный на 4
и т.д. Самый нижний уровень - факториал 1, равный самому себе, и это наша точка выхода из рекурсии.
Выполнение кода:        
fact(4) = fact(3) * 4
              (fact(2) * 3) * 4
                  ((fact(1)*2) * 3) * 4
                     ((1*2) * 3) * 4  на место fact(1) встает 1, она прописана в условии выше                    
                  (2 * 3) * 4 
              6 * 4
          24
           

Логика такая: сводим крупную задачу к более мелкой, ту еще к более мелкой до самой базы ... и стремимся к выходу
из рекурсии.
'''

# Классическая задача на рекурсию: числа Фибонначи

def fi(n):
    if n == 0:
        return 1
    if n == 1:
        return 2
    return fi(n - 1) + fi(n - 2)
'''
Рекуррентная формула выглядит так:
        | 0, если n = 1
F(n) =  | 1, если n = 2
        | F(n-1) + F(n-2) , если n > 2
        
При выполнении кода он срабатывает последовательно, сначала вызывается левая часть формулы, потом правая, 
плюс ветки дублируются. Даже значение 7 элемента выглядит как "огромный куст". 
Попытка найти 70 число вообще вызовет завис. Этот пример больше как иллюстрация, на практике есть примеры эффективнее.
      
'''

# Классическая задача на рекурсию: слова-палиндромы (слово шалаш, любой один символ или просто пустота)

def palindrom(s):
    if len(s) <= 1:
        return True
    if s[0] != s[-1]:
        return False
    return palindrom(s[1:-1])

print(palindrom('шалаш'))  # --> True
print(palindrom('ш'))  # ------> True
print(palindrom('шалаш'))  # --> True
print(palindrom('шала'))  # ---> False
''' 
Пустые слова или один символ - палиндромы, а далее сравниваем первый и последний символы слова друг с другом, 
потом втророй и предпоследний и пр.S
'''
