# ---------- Часть 1 ----------

''' По сути, декоратор - это то же самое замыкание, но во внешнюю функцию подается не переменная, а другая функция, см. конец предыдущего урока про замыкания '''

def decorator(func):

    def inner():
        
        print('start decorator ...')
        func()  # вызываем функцию, что подавали в аргументы
        print('finish decorator ...')

    return inner  # возвращаем без вызова

def say():
    print('hello world')

''' Вызовем внешнюю функцию, подадим ей в аргумент другую функцию и сохраним это в переменную. Переменная стала функцией '''

d = decorator(say)
print(d)  # --> При вызове мы видим, что здесь хранится функция inner(), вложенная в decorator() 

d() # --> при вызове отрабатывает inner(), которая сначала печатает start decorator, потом вызывает переданную функцию say()? которая в свою очередь
    # выводи на печать hello world, потом снова возвращается в inner() и выводит finish decorator:

''' вывод 

    start decorator  
    hello world
    finish decorator  
    
'''

''' Все описанные выше в полной мере совпадает с материалом урока по замыканиям. А что если мы хотим расширить функциональность функции say() 
    за счет возможностей функции decorator()?  
    
    Декоратор - это функция, которая принимает функцию и возвращает функцию, тем самый расширяя функционал принимаемой функции
    
    Важно! Называтся декоратор должен так же, как функция, которую мы хотим расширить, в данном случае say() 
    Мы ее словно подменяем/обновляем , но при записи подмены подаем в нее старую версию функции    

say = decorator(say)  # Теперь по имени say() мы храним функцию inner(), в которую передана функция say()
print(say)  # <function decorator.<locals>.inner at 0x000001D407DD14C0> - по имени say хранится замыкание, а не изначальный код print('hello world')

say()  # обычный вызов функции выведет на печать заданный изначально в say() принт и добавленные декоратором обвесы

''' вывод 
    start decorator ...
    hello world
    finish decorator ...

    '''

''' Как поступить, если исходная функция не только выводит что-то, но и принимает аргументы? 
    Если мы хотим добавить аргументы функциям, то надо добавить их и в замыкании '''

def decorator(func):

    def inner(n, m):  # или для улучшения кода сразу пишем (*args, **kwargs)
        print('start decorator ...')
        func(n, m)   # или для улучшения кода сразу пишем (*args, **kwargs)
        print('finish decorator ...')

    return inner  # без вызова, как положено

def say(name, surname):  # дополняем аргументы и здесь, чтобы при вызове ее в декораторе было что передать в inner() который уже переписан и теперь ждет 2 аргумента
    print('hello', name, surname)

say = decorator(say)

say('Vasya', 'Ivanov')

''' вывод 
    start decorator  
    hello Vasya Ivanov
    finish decorator  
'''

''' Чтобы ищбежать ошибок с возможной необходимостью подавать больше аргументов - сразу прописываем (*args, **kwargs) в inner() и вложенной в нее функции '''

# ------------------------------------------
# Примеры 

''' Пример 1
    Работа с html и добавление тегов'''

# создаем декоратор
def header(func):

    def inner(*args, **kwargs):   
        print('<h1>')
        func(*args, **kwargs)    
        print('</h1>')

    return inner

# создаем нужную функцию
def say(name, surname, age):
    print('hello', name, surname, age)

# декорируем функцию (подмена содержания функции и подача в аргмент старой версии, см. выше)
say = header(say)

# запускаем и проверяем работоспособность, все отлично
say('Vasya', 'Ivanov', 30)

''' вывод 
    <h1>
        hello Vasya Ivanov 30
    </h1>
'''

''' Пример 2
    Множественное декорирование '''

# создадим декоратор для обвеса тегами, аналогично выше, но другие теги
def table(func):

    def inner(*args, **kwargs):  # для улучшения кода сразу пишем (*args, **kwargs)
        print('<table>')
        func(*args, **kwargs)   # для улучшения кода сразу пишем (*args, **kwargs)
        print('</table>')

    return inner

# создаем нужную функцию
def say(name, surname, age):
    print('hello', name, surname, age)

# декорируем декорированную функцию  
say = table(header(say))

say('Vasya', 'Ivanov', 30)

''' вывод 
    <table>
        <h1>
            hello Vasya Ivanov 30
        </h1>
    </table>
'''

''' Как получилось? Сначала вызвали header(), после table(). То есть результат работы первой функции попадает во вторую, 
    поэтому обертка тегами идет последовательно '''

# ВАЖНО! Синтаксически вернее писать не say = table(header(say)), а при помощи тега @ перед функцией '''

@header  # запись аналогична say = header(say)
def say(name, surname, age):
    print('hello', name, surname, age)

say('Vasya', 'Ivanov', 30)
''' вывод 
    <h1>
        hello Vasya Ivanov 30
    </h1>
'''

@header
@table  # аналогично say = table(header(say)) выполняется в обратном порядке, с ближайшей к отдаленной
def say(name, surname, age):
    print('hello', name, surname, age)

say('Vasya', 'Ivanov', 30)
''' вывод 
    <h1>
        <table>
            hello Vasya Ivanov 30
        </table>
    </h1>
'''

# --------------------------------------------------------
# ---------- Часть 2 ----------

# Проблема - как не потерять имя задекорированной функции?
''' При создании функции она получает системное имя '''

# пропишем функцию для последующего декорирования
def say():
    print('hello world')

# удостоверимся, что это декоратор
print(say)  # --> <function __main__.say()>

# узнаем системное имя этой функции
say.__name__  # --> 'say'

''' После декорирования ее название меняется, она ссылается на замыкание '''
say = table(say)
print(say)  # --> <function __main__.table.<locals>.inner(*args, **kwargs)>
say.__name__  # --> 'inner', а изначально было 'say' Так произошло потому что мы перезатерли функцию, подав старую со старым именем в аргумент


''' Аналогичная проблема если создать коментарии при определении функции. При декорировании они тоже теряются, например с новой функцией: '''

def sqr(x):
     """
     Функция возводит в квадрат х
     :param x:
     :return:
     """
     print(x**2)

sqr.__name__  # --> 'sqr'

# вызываем справку, для красивого вывода можно написать help(sqr)
sqr.__doc__  # --> '\n Функция возводит в квадрат х\n     :param x:\n      :return:'  --> есть справка

# декорируем
sqr = table(sqr)
sqr.__doc__  # --> нет справки

''' После декорирования мы потеряем справку, так как у функции inner документации нет '''

''' Решение1
    Вариант решения ВРУЧНУЮ, перед возвратом inner (но вне ее!) пропишем вывод имени и документации, для этого подменяя имя: '''

def table(func):

    def inner(*args, **kwargs):  # для улучшения кода сразу пишем (*args, **kwargs)
        print('<table>')
        func(*args, **kwargs)   # для улучшения кода сразу пишем (*args, **kwargs)
        print('</table>')

    inner.__name__ = func.__name__
    inner.__doc__ = func.__doc__
    return inner

''' Теперь при вызове задекорированной функции у нас выведется справка, то, что прописано перед return inner, 
    за счет того, что оно как раз не в теле функции, а после ''' 

''' Решение 2
    Вариант декоратора wraps. Импортируем библиотеку, аргументом во wraps подаем функцию, которую декорируем 
    wraps напрямую сохраняет значения __name__ и __doc__ из нашей функции, что подана в декоратор '''

from functools import wraps

def table(func):

    @wraps(func)  # важно подать именно декорируемую функцию
    
    def inner(*args, **kwargs):  # для улучшения кода сразу пишем (*args, **kwargs)
        print('<table>')
        func(*args, **kwargs)   # для улучшения кода сразу пишем (*args, **kwargs)
        print('</table>')

    return inner
