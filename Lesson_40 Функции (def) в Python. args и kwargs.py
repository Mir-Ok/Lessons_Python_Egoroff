a, b, c = 7, 8, 9  # множественное присвоение
print(a, b, c)  # --> 7 8 9 подаем во встр. функцию аргументы позиционно, распределяются соотв. положению

''' при такой подаче крайне важно совпадение аргументов при определении функции и при подаче
    a, b, c = [7, 8, 9, 10]   
    print(a, b, c) - ValueError: too many values to unpack (expected 3)
    
    a, b, c = [7, 8]   
    print(a, b, c)
    ValueError: not enough values to unpack (expected 3, got 2)
'''

# Если требуется в три переменных поместить 7 переменных, при помощи оператора звездочки можно выбрать ту переменную,
# которая примет в себя все лишние элементы в виде списка. Оставшиеся 2 возьмут в себя два значния, указанных позиционно

*a, b, c = [True, 7, 'hello', 9, 54, '67', 4]
print(a)  # --> [True, 7, 'hello', 9, 54]
print(b)  # --> 67
print(c)  # --> 4

a, *b, c = [True, 7, 'hello', 9, 54, '67', 4]
print(a)  # --> True
print(b)  # --> [7, 'hello', 9, 54, '67']
print(c)  # --> 4

a, b, *c = [True, 7, 'hello', 9, 54, '67', 4]
print(a)  # --> True
print(b)  # --> 7
print(c)  # --> ['hello', 9, 54, '67', 4]

# можно провернуть подобное со строковой переменной
a, b, *c = 'hello world'
print(a)  # --> h
print(b)  # --> e
print(c)  # --> ['l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd']

# можно при такой подаче не соблюдать численность имен и поданных значений при присвоении. Важно, чтобы
# для обязательных элементов было что подставить, для аргументов со * создасться пустой лист
a, b, *c = [2, 3]
print(a)  # --> 2
print(b)  # --> 3
print(c)  # --> []

# --------------------------------------------
# способы применения

# _1 распаковка листа по переменным

s = [4, 10]
print(list(range(1, 5)))  # --> [1, 2, 3, 4]
# print(list(range(s)))  # --> TypeError: 'list' object cannot be interpreted as an integer
print(list(range(*s)))  # --> [4, 5, 6, 7, 8, 9] оператор * распакует
                        # значения 4 и 10 по соотв. переменным (начало и конец range)

# _2 подача аргументов, распаковка кортежа

def f(a,b,c,d):
    print(a)
    print(b)
    print(c)
    print(d)

a = ('hi', True, 78, [2,3])

# f(a)  # --> f() missing 3 required positional arguments: 'b', 'c', and 'd'
        # просто так кортеж воспринимается
        # как одна переменная, а с * распаковывается поэлементоно и встает в переменные
f(*a)
''' вывод: hi
           True
           78
           [2, 3]
'''

# _3 использование * при определении функции позволяет подать неограниченное число переменных,
   # которые упаковываются в кортеж

def f(*args):
    print(args, type(args))
f(1,2,3,4,5,6)  # --> (1, 2, 3, 4, 5, 6) <class 'tuple'>
f(1,2)  # --> (1, 2) <class 'tuple'>
f()  # --> () <class 'tuple'>

def sum(*args):  # ----- поданные при вызове числа попадут в кортеж
    s = 0
    for i in args:  # -- по кортежу можно пройтись циклом
        s += i
    return s

print(sum(1,2,3))  # --> 6

# _4 подача в функцию через оператор ** позволяет подать неогр. кол-во именованных элементов,
   # которые упаковываются в кортеж

def f(**kwargs):
    print(kwargs)
f(a=1, b=2, c=3)
''' вывод: 
    {'a': 1, 'b': 2, 'c': 3}
'''

def f(**kwargs):
    for k,v in kwargs.items():  # вызываем ключи значение методом словаря .items() b множественно присваиваем значения
        print(k,v)
f(a=1, b=2, c=3)
''' вывод: 
    a 1
    b 2
    c 3
'''
# _5 комбинирование операторов * и **

def f(*args, **kwargs):
    print(args, kwargs)
f(5,4,3,5,4,a=5,b=8,d='hi')
''' вывод: 
    (5, 4, 3, 5, 4) {'a': 5, 'b': 8, 'd': 'hi'}
'''

# _6 пример функция print(), она принимает сперва сколь угодно позиционных, а после параметры, они же именованные аргументы
print(1,2,3,4,5, sep=' ', end='')
print()

def outPrint(*args, sep='@', end='#'):
    print(args, sep, end)
outPrint(1,2,3, sep='88')  # --> (1, 2, 3) 88 #
outPrint(1,2,3, end='555') # --> (1, 2, 3) @ 555
outPrint(1,2,3,)  # -->(1, 2, 3) @ #

# _7 лайфхак

a = [1,2,3,4,5]
print(a)  # --> [1, 2, 3, 4, 5]
print(*a) # --> 1 2 3 4 5 лист распаковывается и подается словно по отдельности, но без переноса строки
