'''
Функция zip получает в качестве аргументов две коллекции, выдает кортежи, из элементов переданных коллеций,
причем в каждом кортеже стоят элементы с одинаковыми индексами
'''

a = [5, 6, 7, 8]
b = [100, 200, 300, 400]

# задача вывести элементы, которые стоят на одной месте в списках, и здесь важно следить за длиной списков,
# чтобы не попасть на out of range (выход за границы списка)
for i in range(4):
    print(a[i], b[i])
    '''
    5 100
    6 200
    7 300
    8 400
    '''

rez = zip(a, b)
print(rez)  # --> <zip object at 0x0000029611927E00> это итератор
print(list(rez))  # --> [(5, 100), (6, 200), (7, 300), (8, 400)]

a = [5, 6, 7]
b = [100, 200, 300, 400]
rez = zip(a, b)
print(list(rez))  # --> [(5, 100), (6, 200), (7, 300)]
# при разной длине коллекций ошибки нет, функция zip сама определяет длину наименьшей последовательности,
# и лишние оставит без внимания

''' Переменная rez является итератором и выводится на печать как лист только в рамках функции print
Напомним, что с итераторами нельзя: получать индекс элемента, считать длину, можно обойти циклом только один раз.
Чтобы не иметь сложностей  сэтим, можно сразу саму переменную rez сделать списком,
тогда можно гонять по циклу сколько угодно раз.

rez = list(zip(a, b))
print(rez)  # --> [(5, 100), (6, 200), (7, 300)]

'''

# ограничений по кол-ву коллекций нет, длина определяется по минималной коллекции
a = [5, 6, 7]
b = [100, 200, 300, 400]
c = 'abcd'
rez = list(zip(a, b, c))
print(rez)  # --> [(5, 100, 'a'), (6, 200, 'b'), (7, 300, 'c')]

# можно итерировать циклом for функцию напрямую
for i in zip(a, b, c):
    print(i)
    ''' вывод 
    (5, 100, 'a')
    (6, 200, 'b')
    (7, 300, 'c')
    '''

# можно итерировать циклом for функцию напрямую с множественным присвоением
for t1, t2, t3 in zip(a, b, c):
    print(t1, t2, t3)
    ''' вывод 
    5 100 a
    6 200 b
    7 300 c
    '''

#  есть возможность вернуть списки обратно при помощи распоковки элементов *

a = [5, 6, 7, 8]
b = [100, 200, 300, 400]
c = 'abcd'
rez = zip(a, b, c)


# символ * создаст из списка 4 элемента (по кол-ву кортежей), функция zip возбмет первые элементы и склеит из них первую
# коллекцию, возьмет вторые и склеит из них вторые ...

print(list(rez))  # --> [(5, 100, 'a'), (6, 200, 'b'), (7, 300, 'c'), (8, 400, 'd')]

col1, col2, col3 = zip(*rez)
print(col1)  # --> (5, 6, 7, 8)
print(col2)  # --> (100, 200, 300, 400)
print(col3)  # --> ('a', 'b', 'c', 'd')